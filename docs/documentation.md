# Введение

## Основные определения

**Свертка** - это формальный язык описания требований к исполнению программ. Эти требования включают в себя:

- Указания к исполнению фрагмента(-ов) кода на определенном узле/узлах
- Хранения фрагмента(-ов) данных и его копию(-и) на определенном узле/узлах
- Порядок исполнения фрагментов кода
- Маршруты перессылки фрагментов данных между узлами

Свертка предоставляет удобный инструментарий из набора блоков описания и операторов исполнения, которые позволяют описать алгоритм решения конкретной задачи. 

Транслятор свертки конкретизирует, как код, написанный на языке свертки, будет интерпретироваться в готовую программу. В теории свертка может быть транслирована в программу на разных языках программирования в зависимости от реализации транслятора.

# Требования к свертке

В процессе разработки языка свертки выдвигаются ряд требований, которым свертка должна соответствовать в конечном результате. Эти требования могут меняться по ходу разработки. На данный момент выделены следующие требования:

- Для исходного кода, описанного на языке свертки, можно реализовать транслятор, который сможет транслировать этот код в готовую программу на одном из языков программирования
- Язык свертки должен предоставлять удобный инструментарий для описания решения задач (блоки описания, операторы исполнения, макроопределения и т.д.) 

# Синтаксис языка свертки

Ниже приведен пример свертки для программы суммы векторов
```
define {
    N_FD = 12; // число фрагментов данных
}

execution {
    run {
        initVectorX[1..$N_DF],
        initVectorY[1..$N_DF],
        sumResultVectorParts[1..$N_DF]
    } on ranks $ALL_RANKS;

    sequential run printVector[1..$N_DF] on rank $ROOT_RANK;
}
```

## Комментарии

Комментарии в свертке аналогичны комментариям в Си-языках

```
// Однострочный комметарий

/*
    Блочный
    комментарий
*/
```

## Макроопределения

Блок *define {...}* задает константы, которые можно использовать через макроподстановку **$CONST_NAME**

```
define {
    N = 6;
    NAME = "LuNA";
    RANKS_LIST = {0, 1, 2};
}
```

Также есть список предпопределенных констант (может пополняться):
- **$SIZE** — количество узлов в топологии
- **$ROOT_RANK** — корневой узел в топологии
- **$ALL_RANKS** — последовательный список всех номеров узлов в топологии

## Блоки описания
Существуют основные и предписывающие блоки описания

### Основные блоки описания
- Блок **define {...}** содержит в себе описания констант
- Блок **execution {...}** содержит описание исполнения программы. В нем описывается вся программа. **Предписывающие блоки исполняются согласно их порядку описания.**

### Предписывающий блок **run {...}**

Данный блок предписывает исполнение фрагмента(-ов) кода на узле(-ах). Если не указано ключевое слово **sequentinal**, то фрагменты кода исполняются согласно их информационной зависимости. Если фрагменты кода независимы, то порядок исполнения может быть любым.

```
// Исполнение фрагмента кода на указанном узле
run task on rank $ROOT_RANK;

// Распределенное исполнение фрагментов кода на указанных узлах
run {
    task1,
    task2,
    task3[1..$N_ND]
} on ranks 0, 1;
```

Иногда возникает необходимость исполнить фрагменты кода строго последовательно — для этого используется ключевое слово **sequentinal**. Блок **sequentinal run {...}** предписывает строго последовательное исполнение фрагментов кода, включая индексированные

```
sequentinal run printVectorPart[1..$N_DF] on rank $ROOT_RANK;
```

