# Введение

## Основные определения

**Свертка** - это язык описания спецификации того, как в итоге должна выглядеть программа. Другими словами, свертка есть описание трансляции алгоритма в программу. 

Основной функционал свертки:

- Указания к исполнению фрагмента(-ов) вычислений на определенном узле или балансировка этой нагрузки между узлами
- Порядок исполнения фрагментов вычислений
- Хранения фрагмента(-ов) данных и его копию(-и) на определенном узле/узлах
- Маршруты перессылки фрагментов данных между узлами
- Переиспользование памяти для фрагментов данных
- Сборка мусора
- И т.п.

LuNA программа без рекомендаций — это описание алгоритма. Программа, в отличии от алгоритма, привязана к ресурсам и содержит управление. Свертка имеет дело с отображением на ресурсы,  она показывает способ превращения алгоритма в программу. 

Транслятор свертки конкретизует определенные алгоритмы генерации конечной программы. Он работает не только со сверткой, но и с программой на LuNA. 
Одной свертки недостаточно.

# Требования к свертке
 
В процессе разработки языка свертки выдвигаются ряд требований, которым свертка должна соответствовать в конечном результате. Эти требования могут меняться по ходу разработки. На данный момент выделены следующие требования:

- Функционал свертки должен быть достаточен, чтобы любую разумную программу можно было получить в некотором (желательно идеальном) приближении

- При наличии исходной LuNA программы (.fa файл) и описанных фрагментов кода (.cpp файл) по свертке можно сгенерировать программу
    
- Язык свертки должен быть простой и предоставлять "джентельменский" набор операторов управления и распределения ресурсов. Операторы должны поддерживаться существующими алгоритмами.

- Свертка конструктивно и явно задает порядок исполнения фрагментов вычислений, а также распределение ресурсов

- Программа, полученная по свертке, должна приближенно соответствовать некоторому идеальному варианту MPI программы в быстродействии

Стоит отметить, что свертка пишется для структурированного фрагмента кода **main**

# Основной синтаксис языка свертки

Ниже приведен пример свертки для программы суммы векторов
```
define {
    N_FD = 12; // число фрагментов данных
}

execution {
    run for i=1..$N_DF {
        initVectorX[i],
        initVectorY[i],
        sumResultVectorParts[i]
    } on ranks $ALL_RANKS;

    run for i=1..$N_DF {
        printVector[i]
    } on rank $ROOT_RANK;
}
```

## Комментарии

Комментарии в свертке аналогичны комментариям в Си-языках

```
// Однострочный комметарий

/*
    Блочный
    комментарий
*/
```

## Макроопределения

Блок *define {...}* задает константы, которые можно использовать через макроподстановку **$CONST_NAME**

```
define {
    N = 6; // Числовая константа
    NAME = "LuNA"; // Строковая константа
    RANKS_LIST = {0, 1, 2}; // Список
}
```

Также есть список предпопределенных констант (может пополняться):
- **$SIZE** — количество узлов в топологии
- **$ROOT_RANK** — корневой узел в топологии
- **$ALL_RANKS** — последовательный список всех номеров узлов в топологии

## Блоки описания
Блоки описания делятся на основные и предписывающие. 

### Основные блоки описания
- Блок **define {...}** содержит в себе описания констант
- Блок **execution {...}** содержит в себе целиком описание трансляции алгоритма в программу 

### Предписывающий блок **run {...}**

Данный блок предписывает исполнение фрагментов вычислений на указанных узлах. Данный блок работает с идентификаторами оператора применения фрагмента кода — **cf**, **для корректной работы идентификаторы должны иметь уникальные имена**. Исполнение происходит в порядке перечисления фрагментов вычислений, если не указано ключевое слово **arbitrary** перед **run**

```
// Исполнение фрагмента кода на указанном узле
run task on rank $ROOT_RANK;

// Балансировка нагрузки на узлах 0, 1
run {
    task1,
    task2,
    task3
} on ranks 0, 1;

// В случае, если нам не важен порядок исполнения фрагментов вычислений внутри тела run
arbitrary run {
    task1,
    task2
} on rank $ROOT_RANK;
```

Иногда возникает необходимость исполнять не поэлементно, а цепочечно. С помощью конструкции **for i=N..M** после **run** мы можем задавать цепочки исполнения. Если не указано ключевое слово  **arbitrary**, то цепочки исполняются от N до M, указанных в цикле for

```
// Балансировка i-ых цепочек исполнения между узлами 0, 1
arbitrary run for i=1..$N_DF {
    initX[i],
    initY[i],
    sumXY[i]
} on ranks 0, 1;
```

Иногда для распаралелливания программы требуется использовать потоки вместо процессов. Для этого в после указания узлов, на которых будут исполняться фрагменты вычислений, нужно указать количество потоков следующим образом

```
run for i=1..$N_DF sumXY[i] on rank $ROOT_RANK with 4 threads;
```
В случае нескольких узлов, на каждом узле будут созданы по N указанных потоков
```
// На каждом узле будут задействаны по два потока на исполнение
run for i=1..$N_DF sumXY[i] on ranks $ALL_RANKS with 2 threads;
```

## Порядок исполнения

Свертка конструктивно и явно должна задавать порядок исполнения фрагментов кода. Ниже описаны правила, по которым регулируется порядок исполнения

1. Предписывающие блоки **run {...}** исполняются согласно их порядку описания в теле основного блока **execution {...}**
    ```
    execution {
        // 1
        run task1 on rank 0;

        // 2
        run { 
            task2, 
            task3
        } on ranks 0, 1;

        // 3 
        run task4 on rank 0;
    }
    ```
2. Порядок исполнения в теле блока **run {...}** регулируется ключевым словом **arbitrary** и конструкцией **for i=N..M**

## Именнованный предписывающий блок run
Предписывающим блокам можно задавать имена, каждое имя должно быть уникальным в свертке для однозначной идентификации. Для этого достаточно приписать имя следующим образом
```
// Именнованный предписывающий блок с именем BlockRun[i]

BlockRun[i] run for j=1..$N {
				initA[i][j],
				initB[i][j],
				calc[i][j]
		} on rank i;
```

# Шаблонизированный цикл
Можно задавать несколько предписывающих блоков run следующими образом 
```
for i=0..$N-1 {
		run for j=0..$N-1 {
				initA[i][j],
				initB[i][j],
				calc[i][j]
		} on rank i;
}
```
Что эквивалентно
```
run for j=0..$N-1 {
        initA[0][j],
        initB[0][j],
		calc[i][j]
} on rank 0;

run for j=0..$N-1 {
        initA[1][j],
        initB[1][j],
		calc[i][j]
} on rank 1;

...

run for j=0..$N-1 {
        initA[$N-1][j],
        initB[$N-1][j],
		calc[i][j]
} on rank $N-1;
```

# Обращение к фрагментам данных
В свертке можно управлять фрагментами данных (на данный момент пока что только в триггерах). **Для корректной работы имена фрагментов данных в LuNA-программе должны быть уникальными.**

```
import c_initDF(name, int) as initDF;

// Имена DF — x, y не являются уникальными
sub func() {
    DF x, y;
}

sub anotherFunc() {
    DF matrix, vector;
}

sub main() {
    DF x, y;
    initDF(x, 2);
    cf BlockRun: initDF(y, 1);
}
```

# Триггеры
Триггеры позволяют определить действия, которые будут выполняться до или после исполнения того или иного именованного блока

## Операторы триггера
Для триггеров определенны следующие операторы управления:

- **clean %DFName%** — выполняет удаление фрагмента данных
 
*Примечание: список будет пополняться*

## Синтаксис триггера
Триггер задается следующим образом
```
before/after BlockRun {
	// Очистка фрагментов данных с прошлой программы
    clean x;
    clean y;
}
```
