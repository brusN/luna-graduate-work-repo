# Введение

## Основные определения

**Свертка** - это язык описания спецификации того, как в итоге должна выглядеть программа. Другими словами, свертка есть описание трансляции алгоритма в программу. 

Основной функционал свертки:

- Указания к исполнению фрагмента(-ов) вычислений на определенном узле или балансировка этой нагрузки между узлами
- Порядок исполнения фрагментов вычислений
- Хранения фрагмента(-ов) данных и его копию(-и) на определенном узле/узлах
- Маршруты перессылки фрагментов данных между узлами
- Переиспользование памяти для фрагментов данных
- Сборка мусора
- И т.п.

LuNA программа без рекомендаций — это описание алгоритма. Программа, в отличии от алгоритма, привязана к ресурсам и содержит управление. Свертка имеет дело с отображением на ресурсы,  она показывает способ превращения алгоритма в программу. 

Транслятор свертки конкретизует определенные алгоритмы генерации конечной программы. Он работает не только со сверткой, но и с программой на LuNA. 
Одной свертки недостаточно.

# Требования к свертке

В процессе разработки языка свертки выдвигаются ряд требований, которым свертка должна соответствовать в конечном результате. Эти требования могут меняться по ходу разработки. На данный момент выделены следующие требования:

- Функционал свертки должен быть достаточен, чтобы любую разумную программу можно было получить в некотором приближении

- При наличии исходной LuNA программы (.fa файл) и описанных фрагментов кода (.cpp файл) по свертке можно сгенерировать программу
    
- Язык свертки должен быть простой и предоставлять "джентельменский" набор операторов управления и распределения ресурсов. Операторы должны поддерживаться существующими алгоритмами.

- Свертка конструктивно и явно задает порядок исполнения фрагментов вычислений, а также распределение ресурсов

- Программа, полученная по свертке, должна приближенно соответствовать некоторому идеальному варианту MPI программы в быстродействии

# Синтаксис языка свертки

Ниже приведен пример свертки для программы суммы векторов
```
define {
    N_FD = 12; // число фрагментов данных
}

execution {
    run for i=1..$N_DF {
        initVectorX[i],
        initVectorY[i],
        sumResultVectorParts[i]
    } on ranks $ALL_RANKS;

    run for i=1..$N_DF {
        printVector[i]
    } on rank $ROOT_RANK;
}
```

## Комментарии

Комментарии в свертке аналогичны комментариям в Си-языках

```
// Однострочный комметарий

/*
    Блочный
    комментарий
*/
```

## Макроопределения

Блок *define {...}* задает константы, которые можно использовать через макроподстановку **$CONST_NAME**

```
define {
    N = 6; // Числовая константа
    NAME = "LuNA"; // Строковая константа
    RANKS_LIST = {0, 1, 2}; // Список
}
```

Также есть список предпопределенных констант (может пополняться):
- **$SIZE** — количество узлов в топологии
- **$ROOT_RANK** — корневой узел в топологии
- **$ALL_RANKS** — последовательный список всех номеров узлов в топологии

## Блоки описания
Блоки описания делятся на основные и предписывающие. 

### Основные блоки описания
- Блок **define {...}** содержит в себе описания констант
- Блок **execution {...}** содержит в себе целиком описание трансляции алгоритма в программу 

### Предписывающий блок **run {...}**

Данный блок предписывает исполнение фрагментов вычислений на указанных узлах. Исполнение происходит в порядке перечисления фрагментов вычислений, если не указано ключевое слово **arbitrary** перед **run**

```
// Исполнение фрагмента кода на указанном узле
run task on rank $ROOT_RANK;

// Балансировка нагрузки на узлах 0, 1
run {
    task1,
    task2,
    task3
} on ranks 0, 1;

// В случае, если нам не важен порядок исполнения фрагментов вычислений внутри тела run
arbitrary run {
    task1,
    task2
} on rank $ROOT_RANK;
```

Иногда возникает необходимость исполнять не поэлементно, а цепочечно. С помощью конструкции **for i=N..M** после **run** мы можем задавать цепочки исполнения. Если не указано ключевое слово  **arbitrary**, то цепочки исполняются от N до M, указанных в цикле for

```
// Балансировка i-ых цепочек исполнения между узлами 0, 1
arbitrary run for i=1..$N_DF {
    initX[i],
    initY[i],
    sumXY[i]
} on ranks 0, 1;
```

Ключевое слово **arbitrary** применимо также и в этом случае
```
// Балансировка i-ых цепочек исполнения между узлами 0, 1. Порядок исполнения тела i-ой  цепочки не важен  
arbitrary run for i=1..$N_DF arbitrary {
    doTask1[i],
    doTask2[i],
    doTask3[i]
} on ranks 0, 1;
```

Иногда для распаралелливания программы требуется использовать потоки вместо процессов. Для этого в после указания узлов, на которых будут исполняться фрагменты вычислений, нужно указать количество потоков следующим образом

```
run for i=1..$N_DF sumXY[i] on rank $ROOT_RANK with 4 threads;
```
В случае нескольких узлов, на каждом узле будут созданы по N указанных потоков
```
// На каждом узле будут задействаны по два потока на исполнение
run for i=1..$N_DF sumXY[i] on ranks $ALL_RANKS with 2 threads;
```

## Порядок исполнения

Свертка конструктивно и явно должна задавать порядок исполнения фрагментов кода. Ниже описаны правила, по которым регулируется порядок исполнения

1. Предписывающие блоки **run {...}** исполняются согласно их порядку описания в теле основного блока **execution {...}**
    ```
    execution {
        // 1
        run task1 on rank 0;

        // 2
        run { 
            task2, 
            task3
        } on ranks 0, 1;

        // 3 
        run task4 on rank 0;
    }
    ```
2. Порядок исполнения в теле блока **run {...}** регулируется ключевым словом **arbitrary** и конструкцией **for i=N..M**